package nl.helico.ktorize.assetmapper

import org.gradle.api.DefaultTask
import org.gradle.api.file.SourceDirectorySet
import org.gradle.api.tasks.OutputFile
import org.gradle.api.tasks.SourceSet.MAIN_SOURCE_SET_NAME
import org.gradle.api.tasks.SourceSetContainer
import org.gradle.api.tasks.TaskAction
import org.gradle.configurationcache.extensions.capitalized
import java.nio.file.Path
import javax.inject.Inject
import javax.inject.Provider
import kotlin.collections.ArrayDeque
import kotlin.io.path.*

abstract class GenerateStaticAssetsTask @Inject constructor(
    private val sourceSetContainer: SourceSetContainer,
    private val extension: AssetMapperExtension,
    private val assetMapperProvider: Provider<AssetMapper>,
) : DefaultTask() {

    companion object {
        val NAME = "generateStaticAssets"
        val DESCRIPTION = "Generate static assets"
    }

    init {
        group = AssetMapperPlugin.GROUP
        description = DESCRIPTION

        registerSourceSet()
    }

    private fun getGeneratedDirectory() = extension.getGeneratedDirectory().resolve("kotlin")

    @get:OutputFile
    val outputFile = getGeneratedDirectory().resolve("AssetMapper.kt")

    @OptIn(ExperimentalPathApi::class)
    @TaskAction
    fun run() {
        requireNotNull(extension.packageName.orNull) { "packageName must be set" }

        logger.lifecycle("Generating static assets")

        getGeneratedDirectory().mkdirs()

        val basePath = extension.getResourcesPath()

        logger.lifecycle("Mapping all assets in $basePath")

        val results = basePath.walk().mapNotNull { path ->
            val relative = basePath.relativize(path)
            if (!path.isRegularFile()) return@mapNotNull null

            val result = assetMapperProvider.get().map(relative)

            when (result) {
                is AssetMapper.MapResult.Mapped -> result.output.copy(
                    input = result.output.input.copy(
                        path = Path("assets").resolve(result.output.input.path)
                    )
                )
                else -> null
            }
        }.toList()

        val actions = transformOutputsToActions(results)

        val assetsFile = generateAssetsFileContents(actions)
        outputFile.writeText(assetsFile)
    }

    private fun registerSourceSet() {
        val main = sourceSetContainer.getByName(MAIN_SOURCE_SET_NAME)
        (main.extensions.getByName("kotlin") as SourceDirectorySet).apply {
            srcDir(getGeneratedDirectory())
        }
    }

    private fun transformOutputsToActions(outputs: List<Asset.Output>): List<Action> {
        val actions = mutableListOf<Action>()

        var currentPath = Path(".")

        outputs.forEach { output ->
            val relative = output.input.path.relativeTo(currentPath)

            if (relative.parent == null) {
                actions.add(Action.DescribeAsset(output))
                return@forEach
            }

            val elements = relative.parent.toList()

            elements.forEach { element ->
                when {
                    element.endsWith("..") -> actions.add(Action.EndObject(currentPath))
                    else -> actions.add(Action.StartObject(currentPath.resolve(element)))
                }
            }

            actions.add(Action.DescribeAsset(output))

            currentPath = output.input.path.parent ?: Path(".")
        }

        return actions
    }

    private fun generateAssetsFileContents(actions: List<Action>): String {
        val builder = StringBuilder().apply {

            appendLine("// This file is generated by the AssetMapper plugin")
            appendLine("package ${extension.packageName.get()}")
            appendLine()

            appendLine(
                """      
            import io.ktor.server.http.content.staticResources
                  
            internal object Immutable : io.ktor.http.CacheControl(null) {
              override fun toString(): String = "immutable"
            }
            
            fun io.ktor.server.routing.Routing.staticMappedResources(): io.ktor.server.routing.Route {
                return staticResources("/assets", "assets") {
                    cacheControl {
                        listOf(io.ktor.http.CacheControl.MaxAge(365 * 24 * 3600), Immutable)
                    }
                }
            }
        """.trimIndent()
            )

            appendLine()

            appendLine("""                
                sealed interface AssetTree {
                    interface Folder : AssetTree {
                        val items: List<AssetTree>
                    }
                    data class File(val path: String) : AssetTree
                }
                
                fun kotlinx.html.FlowContent.asset(asset: AssetTree.File) = asset.path
            """.trimIndent())


            var currentIndent = 0
            val itemsStack = ArrayDeque<MutableList<String>>()

            itemsStack.addFirst(mutableListOf())

            actions.forEach { action ->
                when (action) {
                    is Action.StartObject -> {
                        appendLine()
                        val name = generateVariableName(action.path.fileName.toString())
                        itemsStack.first().add(name)
                        itemsStack.addFirst(mutableListOf())

                        append("    ".repeat(currentIndent))
                        append("object $name : AssetTree.Folder {")
                        currentIndent++
                    }

                    is Action.EndObject -> {
                        generateItemsList(currentIndent, itemsStack.removeFirst())

                        append("    ".repeat(currentIndent - 1))
                        append("}")
                        currentIndent--
                    }

                    is Action.DescribeAsset -> {
                        val name = generateVariableName(action.asset.input.path.fileName.toString())
                        itemsStack.first().add(name)
                        append("    ".repeat(currentIndent))
                        append("val ")
                        append(name)
                        append(" = ")
                        append("AssetTree.File(path=\"${action.asset.path}\")")
                    }
                }
                append(System.lineSeparator())
            }

            while (currentIndent > 0) {
                generateItemsList(currentIndent, itemsStack.removeFirst())
                append("    ".repeat(currentIndent - 1))
                append("}")
                append(System.lineSeparator())
                currentIndent--
            }
        }

        return builder.toString()
    }

    private fun generateVariableName(input: String): String {
        return input.replace(Regex("[^a-zA-Z0-9]"), "_").capitalized()
    }

    private fun StringBuilder.generateItemsList(currentIndent: Int, items: List<String>) {
        if (items.isNotEmpty()) {
            appendLine()
            append("    ".repeat(currentIndent))
            append("override val items = listOf(")
            append(items.joinToString(", "))
            appendLine(")")
        }
    }

    sealed interface Action {
        data class StartObject(val path: Path) : Action
        data class DescribeAsset(val asset: Asset.Output) : Action
        data class EndObject(val path: Path) : Action
    }
}